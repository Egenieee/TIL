## Protocol layers, service models (1.5)

<br>

### **Protocol “layers”**

**계층 개념**은 컴퓨터 네트워크에서 굉장이 중요한 개념이다. 어떤식으로 네트워크를 organize할 건지가 굉장히 중요한 이슈였다.

<br>

### **Organization of air travel**

비행기 티켓을 끊어서 여행을 가는 예로 이해를 해보자. 

우리가 비행기를 타고 여행을 가자고 가정을 했을 때, 일단 티켓을 사야한다(puchse). 티켓을 샀으면 해당 날짜에 출발한다. 짐을 부치고(check) 해당되는 게이트로 간다(load). 그런 다음 이륙한다(runway takeoff). 출발하면 비행기가 경로를 따라서 이동한다(airplane routing). 

이동해서 목적지에 도달하면 착륙한다. 게이트로 나와서 짐을 찾는다. 

위 과정을 잘라서 **모듈화**를 하면 어떨까? 티켓관련 일만하는 계층, 짐관련된 일만하는 계층 등등.. 

수화물만 전담하는 팀, 티켓만 전담하는 팀, 이착륙만 전담하는 팀 등에 사람을 배치한다. 이렇게 하면 업무가 잘 돌아가지 않을까?


<br>

### **Why layering?**

왜 **layer**를 사용할까? 복잡한 시스템을 다루기 위해서이다. 

- 명시적인 구조는 복잡한 시스템 조각의 식별, 관계를 가능하게 한다.
- 모듈화는 유지보수, 그리고 시스템의 업데이트를 용이하게 한다.


<br>

### **Internet protocol stack**

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/81270604/217539048-9c7c36d9-f1f6-4f2f-a56e-bd7248d27cf0.png" width=400>
</p>
<br>

그림과 같이 계층을 나눴다.

- `application` : 실제 돌리고자 하는 **응용 프로그램**이 있는 계층
    - 다양한 응용프로그램이 사용자와의 상호 작용하에 동작
    - 대표적인 응용 프로그램으로는 웹 브라우저, 이메일, 파일 전송, 화상회의 등이 있다.
    - 대부분의 응용 프로그램은 클라이언트-서버 모델을 기반으로 설계된다.
    - 프로토콜 : HTTP, DNS, SIP, SMTP, DHCP, Telnet
  
<br>

- `transport` : **전송 프로토콜**에 대해 정의하는 계층
    - end-to-end의 사용자들이 신뢰성 있는 데이터를 주고 받을 수 있도록 패킷들의 전송이 유효한 지 확인하고 효율적인 전송을 수행하는 역할을 담당하는 계층이다.
    - 수신된 패킷을 receiver의 여러 응용 프로그램 중 정확한 목적지 응용 프로그램으로 전달하기 위해 포트 번호를 사용하여 응용 프로그램을 식별한다.
    - 신뢰성 있는 전송, 흐름 제어, 혼잡 제어
    - 프로토콜 : TCP, UDP, SCTP

<br>

- `network` : 목적지까지 가는 **라우팅**
    - 인터넷 프로토콜에 대해 정의하는 계층이다.
    - sender가 위치한 컴퓨터와 receiver가 위치한 컴퓨터 사이의 다양한 네트워크 경로를 연결하는 역할을 수행한다.
    - 출발지와 목적지 장치뿐 아니라 중간에서 최적의 경로를 설정하는 장치인 라우터에도 고유한 식별번호로 IP 주소를 부여한다.
    - 라우터는 수신된 패킷에 담긴 목적지의 주소를 읽고 가장 최적의 통신 경로를 찾아서 다음 목적지로 전달한다.
    - 주요 장비 : 라우터
    - 프로토콜 : IP, ICMP, IGMP, IPSec 등

<br>

- `link` : 링크상에 **송수신**하는 부분
    - 이웃한 네트워크 요소 사이의 데이터 이동
    - 주요 장치 : 스위치, 브릿지
    - 프로토콜 : 이더넷, 프레임 릴레이, ARP, PPP, L2TP

<br>

- `physical` : **물리적으로 통신**하는 부분
    - 패킷을 0과 1로 된 2진수 비트 신호로 다루는 계층
    - 주요 장비 : 허브, 리피터
    - 프로토콜 : RS-232, 이더넷, 블루투스, USB, E1, T1

<br>

각 레이어 별로 프로토콜이 생기게된다.

<br>


택배를 보내는 것으로 생각해보자. 

- `application` : 택배를 요청하는 것
- `transport` : 목적지에서 부모님이 잘 받았다고 확인하는 것 end-to-end에서는 어떤 경로로 왔는지 중요하지 않다. 잘 왔는지 안왔는지가 중요. 이것을 확인하는 것이 transport
- `network` : 택배 목적지가 수원 → 부산이라고 치면 수원 → 용인 → 경상도 → 부산 이 경로를 따지는 것을 network라고 한다.
- `link` : 택배 기사님이 내 것을 싣어서 수원 집하장으로 택배를 모아서 분류해서 분류된걸 부산으로간다고 했을 때 `[지역 → 지역]` 이것을 하나의 링크라고 한다. 링크를 거쳐거쳐 목적지까지 가는 것
- `physical` : 내 택배를 싣고 가는 것


<br>

### ISO/OSI reference model

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/81270604/217539477-b356e4d5-bc0b-4664-9b68-4609b2292cf3.png" width=400>
</p>
<br>

이 모델은 7개의 layers이다. 기억하자. 국제 표준 기구에서는 7개로 정의해서 쓴다. application과 transport 사이에서 뭘 더 할 수 있지 않을까 해서 두개가 추가된 형태. 쉽게 뭐 application을 세개로 쪼갠 것으로 볼 수 있겠다.

- `presentation` : 암호화, 압축 등등
- `session` : 동기화 등

**계층 순서는 꼭 기억하자**

<br>

### **Encapsulation**

<br>
<p align="center">
<img src="https://user-images.githubusercontent.com/81270604/217540543-4f276f0b-a5f1-419b-826c-56d889facf8b.png" width=800>
</p>
<br>

`source`에서 `destination`으로 패킷이 이동한다. 

메세지를 보낸다고 하면, 일단 source에서 계층 하나하나를 거치며 내려온다. 내려오면서 헤더가 하나씩 붙는다. 각각의 계층에서 무언갈 하기 위해서 헤더를 하나씩 붙인다. 목적지에서 헤더를 하나씩 읽어보면서 뭘 해야하는지 알게 되는 것이다. 택배보낼 때 운송장 붙이는 것이랑 비슷한 개념~

**H → Header**

application layer에서 처음 보낼 때는 **message**였는데 transport layer에서는 **segment**로 바뀜. 또 하나 내려가니 헤더가 하나 더 붙고 **datagram**으로 이름이 바뀐다. 또또 link layer로 내려오면 또 헤더가 붙고 **frame**으로 이름이 바뀐다.

왜 이름이 다를까? 각 계층별로 바라보는 시각이 다르기 때문이다. 

source에서 떠난 데이터는 switch와 router로 흘러간다. 왜 링크 계층까지만 있을까? 네트워크까지 읽을 필요가 없다. 좁은 지역내에서 쓰기 때문이다. 

<br>

>switch와 router의 차이점은? 
>
>읽어보는 계층이 다르다. 라우터는 네트워크의 헤더를 보고 라우팅을 한다. 네트워크의 계층에는 IP 주소가 들어있다. 스위치는 링크 계층의 헤더까지만 읽어본다. 링크 계층에는 MAC 주소가 들어있다.

<br>

router에서는 위로 올라가면서 링크 헤더를 떼고 네트워크 계층을 본 뒤 다시 링크 헤더를 붙여서 목적지로 보낸다. 목적지에선 헤더를 하나 씩 까면서 메세지를 확인한다. 

최종적으로 보낸 message와 받은 message가 일치해야 성공!

정리하면 헤더를 까서 읽고 새로운 헤더를 붙여서 다시 보내는 것이다.